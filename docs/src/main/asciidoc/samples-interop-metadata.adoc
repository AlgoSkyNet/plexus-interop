==== Point-to-point interop between two apps

App A and App B are developed by different dev teams in different languages: C# and Java. App A consumes service FX.ExchangeRateService provided by App B.

. Both apps developers decides and defines public API in proto format
+
[source,php]
.Public API definition in proto format (FX.proto)
----
syntax = "proto3";

package FX;

message Pair {
    string id = 1;
}

message PairExchangeRate {
    Pair pair = 1;
    double exhchange_rate = 2;
}

service ExchangeRateService {
    rpc GetExchangeRate (Pair) returns (PairExchangeRate);
}
----

. Developer of App A defines public contract in plexus format
+
[source,php]
.Public contract of App A (AppA.plexus)
----
application ExampleCompany1.AppA {
    consumes FX.ExchangeRateService.{GetExchangeRate} from ExampleCompany2.AppB;
}
----

. Developer of App B defines public contract in plexus format
+
[source,php]
.Public contract of App B (AppB.plexus)
----
application ExampleCompany2.AppB {
    provides FX.ExchangeRateService.{GetExchangeRate} to ExampleCompany1.AppA;
}
----

. App A developer calls *plexus gen proto AppA.plexus AppA.proto* to generate API description in proto format, and decorates it
 by adding option csharp_namespace.
+
[source,php]
.Generated API for App A in proto format (AppA.proto)
----
syntax = "proto3";
package ExampleCompany1.AppA;
option csharp_namespace = "ExampleCompany1.AppA";

message Pair {
    option (plexus.reference) = "FX.Pair";
    string id = 1;
}

message PairExchangeRate {
    option (plexus.reference) = "FX.PairExchangeRate";
    Pair pair = 1;
    double exchange_rate = 2;
}

service ExchangeRateService {
    option (plexus.reference) = "FX.ExchangeRateService";
    option (plexus.consume) = true;
    rpc GetExchangeRate (Pair) returns (PairExchangeRate) {}
}
----

. App B developer calls *plexus gen proto AppB.plexus AppB.proto* to generate API description in proto format, and decorates it
 by adding option java_package.
+
[source,php]
.Generated API for App B in proto format (AppB.proto)
----
syntax = "proto3";
package ExampleCompany2.AppB;
option java_package = "com.exampleCompany2.appB";

message Pair {
    option (plexus.reference) = "FX.Pair";
    string id = 1;
}

message PairExchangeRate {
    option (plexus.reference) = "FX.PairExchangeRate";
    Pair pair = 1;
    double exchange_rate = 2;
}

service ExchangeRateService {
    option (plexus.reference) = "FX.ExchangeRateService";
    option (plexus.provide) = true;
    rpc GetExchangeRate (Pair) returns (PairExchangeRate) {}
}
----

. App A developer calls *plexus gen dotnet AppA.proto -v 1.0* to generate nuget package "ExampleCompany1.AppA.Plexus.1.0.nupkg" with app-specific Plexus contracts,
 and uses the generated package to provide implementation of ExchangeRateService to App B.

. App B developer calls *plexus gen java AppB.proto -v 1.0* to generate maven package "com.exampleCompany2.appB.1.0.jar" with app-specific Plexus contracts,
 and uses the generated package to use implementation of ExchangeRateService provided by App A.

==== Service discovery

App A searches for the different implementations of FX.ExchangeRateService and shows list of the discovered implementations to user
allowing to choose which implementation to use. App B and App C provides two different implementations of the service.

[source,php]
.Public contract of App A (AppA.plexus)
----
application ExampleCompany1.AppA {
    consumes FX.ExchangeRateService.{GetExchangeRate};
}
----

[source,php]
.Public contract of App B (AppB.plexus)
----
application ExampleCompany2.AppB {
    provides FX.ExchangeRateService.{
        @Title({value : "Get Exchange Rate from Company 2"})
        GetExchangeRate
    };
}
----

[source,php]
.Public contract of App C (AppC.plexus)
----
application ExampleCompany3.AppC {
    provides FX.ExchangeRateService.{
        @Title({value: "Exchange Rate by Company 3"})
        GetExchangeRate
    };
}
----

==== Several species of the same application

Both App A and App B has PROD and DEMO instances. PROD and DEMO instance can be installed side-by-side in the same system.
App A PROD must only communicate to App B PROD, and App A DEMO must only communicate to App B DEMO. It must not be possible
to communicate from PROD instance of one app to DEMO instance of another app. Implementations of apps are the same for
PROD, DEMO, or any other environments. The only difference is server URL which can be passed through configuration file
or command-line argument.

[source,php]
.Public contract of App A (AppA.plexus)
----
application ExampleCompany1.AppA {
    consumes FX.ExchangeRateService.{GetExchangeRate}
        as ExchangeRateService
        from ExampleCompany2.AppB;

    alias ExampleCompany1.AppADemo {
        consumes ExchangeRateService from ExampleCompany2.AppBDemo;
    }
}
----

[source,php]
.Public contract of App B (AppB.plexus)
----
application ExampleCompany2.AppB {
    provides FX.ExchangeRateService.{GetExchangeRate}
        as ExchangeRateService
        to ExampleCompany1.AppA;

    alias ExampleCompany2.AppBDemo {
        provides ExchangeRateService to ExampleCompany1.AppADemo;
    }
}
----

==== Component shared by different apps

App A and App B internally uses the same FX.Common.Component which consumes implementation of FX.ExchangeRateService provided
by FX.Common.ServiceHost through Plexus.

[source,php]
.Public contract of FX.Common.Component (FX.Common.Component.plexus)
----
component FX.Common.Component {
    consumes FX.ExchangeRateService.{GetExchangeRate} from FX.Common.ServiceHost;
}
----

[source,php]
.Public contract of FX.Common.ServiceHost (FX.Common.ServiceHost.plexus)
----
application FX.Common.ServiceHost {
    provides FX.ExchangeRateService.{GetExchangeRate} to FX.Common.Component;
}
----

[source,php]
.Public contract of App A (AppA.plexus)
----
application ExampleCompany1.AppA {
    includes FX.Common.Component;
}
----

[source,php]
.Public contract of App B (AppB.plexus)
----
application ExampleCompany2.AppB {
    includes FX.Common.Component;
}
----

==== Modularised application

App A is a big application which consist of Component 1 and Component 2 and other components each developed by different teams.

[source,php]
.Public contract of App A (AppA.plexus)
----
application ExampleCompany1.AppA {
    component ExampleCompany1.Component1 {
        consumes FX.ExchangeRateService.{GetExchangeRate};
    }

    component ExampleCompany2.Component2 {
        provides FX.ExchangeRateService.{GetExchangeRate};
    }
}
----

==== Application running in container (e.g. Electron, NW.js, OpenFin...)

App A and App B are web apps running in the same container. Container starts them and manages their lifecycle.
App C is a simple .NET app running without container. App A consumes service from App C, App C consumes service from App B.

==== Streaming

App A and App B (and possibly other apps) use the same service to get FX rates. To not create several connections for the same data
(it might be expensive) they connect to additional "invisible" application App C which holds one connection to server and streams all the received
rates to the subscribers.

==== Intents

User enters some free-text unstructured data in App A. App A searches all the interop methods which can handle the entered text
and shows them to user. User chooses which action to execute. App B and App C implements methods which can be discovered and executed.